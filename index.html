<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Block Blast Advanced</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;font-family:sans-serif;}
body{
    background:linear-gradient(135deg,#fff9c4,#ffe0b2);
    display:flex;
    justify-content:center;
    align-items:center;
    min-height:100vh;
}
.container{width:100%;max-width:500px;text-align:center;}
.menu,.game{
    background:white;
    padding:20px;
    border-radius:20px;
    box-shadow:0 10px 30px rgba(0,0,0,0.15);
}
.game{display:none;}

h1{color:#ff7675;margin-bottom:10px;}

button{
    padding:12px 20px;
    border:none;
    border-radius:12px;
    background:#74b9ff;
    color:white;
    font-size:16px;
    cursor:pointer;
}

.board{
    display:grid;
    grid-template-columns:repeat(8,1fr);
    gap:4px;
    margin:15px 0;
}

.cell{
    width:100%;
    padding-top:100%;
    position:relative;
    background:#ecf0f1;
    border-radius:8px;
    transition:0.2s;
}

.cell.filled{
    background:#55efc4;
}

.cell.clear{
    animation:pop 0.3s ease;
}

@keyframes pop{
    0%{transform:scale(1);}
    50%{transform:scale(1.3);}
    100%{transform:scale(0);}
}

.blocks{
    display:flex;
    justify-content:space-around;
}

.block{
    display:grid;
    gap:3px;
    touch-action:none;
}

.block div{
    width:22px;
    height:22px;
    background:#a29bfe;
    border-radius:5px;
}

.score{margin:8px 0;}
.combo{
    color:#e17055;
    font-weight:bold;
}
</style>
</head>
<body>

<div class="container">

<div class="menu" id="menu">
<h1>Block Blast</h1>
<p>최고 기록: <span id="bestScore">0</span></p>
<br>
<button onclick="startGame()">게임 시작</button>
</div>

<div class="game" id="game">
<h2>점수: <span id="score">0</span></h2>
<div class="combo" id="combo"></div>
<div class="board" id="board"></div>
<div class="blocks" id="blocks"></div>
<br>
<button onclick="goMenu()">메뉴</button>
</div>

</div>

<script>
const SIZE=8;
let board=[];
let score=0;
let combo=0;
let bestScore=localStorage.getItem("bestScore")||0;
document.getElementById("bestScore").textContent=bestScore;

const shapes=[
[[1]],[[1,1]],[[1],[1]],
[[1,1,1]],[[1],[1],[1]],
[[1,1],[1,1]],
[[1,0],[1,1]],
[[0,1],[1,1]]
];

function startGame(){
    document.getElementById("menu").style.display="none";
    document.getElementById("game").style.display="block";
    init();
}

function goMenu(){
    document.getElementById("game").style.display="none";
    document.getElementById("menu").style.display="block";
}

function init(){
    board=Array(SIZE).fill().map(()=>Array(SIZE).fill(0));
    score=0;
    combo=0;
    updateScore();
    drawBoard();
    generateBlocks();
}

function drawBoard(){
    const boardDiv=document.getElementById("board");
    boardDiv.innerHTML="";
    for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
            const cell=document.createElement("div");
            cell.className="cell";
            if(board[r][c]) cell.classList.add("filled");
            cell.dataset.r=r;
            cell.dataset.c=c;
            boardDiv.appendChild(cell);
        }
    }
}

let currentBlocks=[];
let draggingShape=null;

function generateBlocks(){
    const blocksDiv=document.getElementById("blocks");
    blocksDiv.innerHTML="";
    currentBlocks=[];
    for(let i=0;i<3;i++){
        const shape=JSON.parse(JSON.stringify(shapes[Math.floor(Math.random()*shapes.length)]));
        currentBlocks.push(shape);
        const blockDiv=document.createElement("div");
        blockDiv.className="block";
        blockDiv.style.gridTemplateColumns=`repeat(${shape[0].length},22px)`;
        shape.forEach(row=>{
            row.forEach(cell=>{
                const mini=document.createElement("div");
                if(!cell) mini.style.visibility="hidden";
                blockDiv.appendChild(mini);
            });
        });

        blockDiv.addEventListener("pointerdown",()=>{
            draggingShape=shape;
        });

        blocksDiv.appendChild(blockDiv);
    }
}

document.addEventListener("pointerup",(e)=>{
    if(!draggingShape) return;
    const target=document.elementFromPoint(e.clientX,e.clientY);
    if(target && target.classList.contains("cell")){
        const r=parseInt(target.dataset.r);
        const c=parseInt(target.dataset.c);
        if(canPlace(draggingShape,r,c)){
            placeShape(draggingShape,r,c);
        }
    }
    draggingShape=null;
});

function canPlace(shape,r,c){
    for(let i=0;i<shape.length;i++){
        for(let j=0;j<shape[0].length;j++){
            if(shape[i][j]){
                if(r+i>=SIZE||c+j>=SIZE||board[r+i][c+j]) return false;
            }
        }
    }
    return true;
}

function placeShape(shape,r,c){
    shape.forEach((row,i)=>{
        row.forEach((cell,j)=>{
            if(cell) board[r+i][c+j]=1;
        });
    });

    score+=10;
    let cleared=clearLines();
    if(cleared>0){
        combo++;
        score+=cleared*50*combo;
        document.getElementById("combo").textContent=`콤보 x${combo}`;
    }else{
        combo=0;
        document.getElementById("combo").textContent="";
    }

    drawBoard();
    generateBlocks();
    updateScore();
    checkGameOver();
}

function clearLines(){
    let cleared=0;

    for(let i=0;i<SIZE;i++){
        if(board[i].every(v=>v)){
            for(let c=0;c<SIZE;c++){
                animateClear(i,c);
                board[i][c]=0;
            }
            cleared++;
        }
        if(board.every(row=>row[i])){
            for(let r=0;r<SIZE;r++){
                animateClear(r,i);
                board[r][i]=0;
            }
            cleared++;
        }
    }
    return cleared;
}

function animateClear(r,c){
    const index=r*SIZE+c;
    const cell=document.getElementById("board").children[index];
    cell.classList.add("clear");
}

function updateScore(){
    document.getElementById("score").textContent=score;
    if(score>bestScore){
        bestScore=score;
        localStorage.setItem("bestScore",bestScore);
        document.getElementById("bestScore").textContent=bestScore;
    }
}

function checkGameOver(){
    for(let shape of currentBlocks){
        for(let r=0;r<SIZE;r++){
            for(let c=0;c<SIZE;c++){
                if(canPlace(shape,r,c)) return;
            }
        }
    }
    alert("게임 오버!");
    goMenu();
}
</script>
</body>
</html>
